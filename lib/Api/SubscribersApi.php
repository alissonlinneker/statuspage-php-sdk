<?php
/**
 * SubscribersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Statuspage API
 *
 * # Code of Conduct Please don't abuse the API, and please report all feature requests and issues to https://support.atlassian.com/contact  # Rate Limiting Each API token is limited to 1 request / second as measured on a 60 second rolling window. To get this limit increased, please contact us at https://support.atlassian.com/contact  Error codes 420 or 429 indicate that you have exceeded the rate limit and the request has been rejected.  # Basics  ## HTTPS It's required  ## URL Prefix In order to maintain version integrity into the future, the API is versioned. All calls currently begin with the following prefix:    https://api.statuspage.io/v1/  ## RESTful Interface Wherever possible, the API seeks to implement repeatable patterns with logical, representative URLs and descriptive HTTP verbs. Below are some examples and conventions you will see throughout the documentation.  * Collections are buckets: https://api.statuspage.io/v1/pages/asdf123/incidents.json * Elements have unique IDs: https://api.statuspage.io/v1/pages/asdf123/incidents/jklm456.json * GET will retrieve information about a collection/element * POST will create an element in a collection * PATCH will update a single element * PUT will replace a single element in a collection (rarely used) * DELETE will destroy a single element  ## Sending Data Information can be sent in the body as form urlencoded or JSON, but make sure the Content-Type header matches the body structure or the server gremlins will be angry.  All examples are provided in JSON format, however they can easily be converted to form encoding if required.  Some examples of how to convert things are below:      // JSON     {       \"incident\": {         \"name\": \"test incident\",         \"components\": [\"8kbf7d35c070\", \"vtnh60py4yd7\"]       }     }      // Form Encoded (using curl as an example):     curl -X POST https://api.statuspage.io/v1/example \\       -d \"incident[name]=test incident\" \\       -d \"incident[components][]=8kbf7d35c070\" \\       -d \"incident[components][]=vtnh60py4yd7\"  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SubscribersApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SubscribersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deletePagesPageIdSubscribersSubscriberId' => [
            'application/json',
        ],
        'getPagesPageIdSubscribers' => [
            'application/json',
        ],
        'getPagesPageIdSubscribersCount' => [
            'application/json',
        ],
        'getPagesPageIdSubscribersHistogramByState' => [
            'application/json',
        ],
        'getPagesPageIdSubscribersSubscriberId' => [
            'application/json',
        ],
        'getPagesPageIdSubscribersUnsubscribed' => [
            'application/json',
        ],
        'patchPagesPageIdSubscribersSubscriberId' => [
            'application/json',
        ],
        'postPagesPageIdSubscribers' => [
            'application/json',
        ],
        'postPagesPageIdSubscribersReactivate' => [
            'application/json',
        ],
        'postPagesPageIdSubscribersResendConfirmation' => [
            'application/json',
        ],
        'postPagesPageIdSubscribersSubscriberIdResendConfirmation' => [
            'application/json',
        ],
        'postPagesPageIdSubscribersUnsubscribe' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deletePagesPageIdSubscribersSubscriberId
     *
     * Unsubscribe a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  bool $skip_unsubscription_notification If skip_unsubscription_notification is true, the subscriber does not receive any notifications when they are unsubscribed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function deletePagesPageIdSubscribersSubscriberId($page_id, $subscriber_id, $skip_unsubscription_notification = null, string $contentType = self::contentTypes['deletePagesPageIdSubscribersSubscriberId'][0])
    {
        list($response) = $this->deletePagesPageIdSubscribersSubscriberIdWithHttpInfo($page_id, $subscriber_id, $skip_unsubscription_notification, $contentType);
        return $response;
    }

    /**
     * Operation deletePagesPageIdSubscribersSubscriberIdWithHttpInfo
     *
     * Unsubscribe a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  bool $skip_unsubscription_notification If skip_unsubscription_notification is true, the subscriber does not receive any notifications when they are unsubscribed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePagesPageIdSubscribersSubscriberIdWithHttpInfo($page_id, $subscriber_id, $skip_unsubscription_notification = null, string $contentType = self::contentTypes['deletePagesPageIdSubscribersSubscriberId'][0])
    {
        $request = $this->deletePagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $skip_unsubscription_notification, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Subscriber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Subscriber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Subscriber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Subscriber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Subscriber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePagesPageIdSubscribersSubscriberIdAsync
     *
     * Unsubscribe a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  bool $skip_unsubscription_notification If skip_unsubscription_notification is true, the subscriber does not receive any notifications when they are unsubscribed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePagesPageIdSubscribersSubscriberIdAsync($page_id, $subscriber_id, $skip_unsubscription_notification = null, string $contentType = self::contentTypes['deletePagesPageIdSubscribersSubscriberId'][0])
    {
        return $this->deletePagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo($page_id, $subscriber_id, $skip_unsubscription_notification, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo
     *
     * Unsubscribe a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  bool $skip_unsubscription_notification If skip_unsubscription_notification is true, the subscriber does not receive any notifications when they are unsubscribed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo($page_id, $subscriber_id, $skip_unsubscription_notification = null, string $contentType = self::contentTypes['deletePagesPageIdSubscribersSubscriberId'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Subscriber';
        $request = $this->deletePagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $skip_unsubscription_notification, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePagesPageIdSubscribersSubscriberId'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  bool $skip_unsubscription_notification If skip_unsubscription_notification is true, the subscriber does not receive any notifications when they are unsubscribed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $skip_unsubscription_notification = null, string $contentType = self::contentTypes['deletePagesPageIdSubscribersSubscriberId'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling deletePagesPageIdSubscribersSubscriberId'
            );
        }

        // verify the required parameter 'subscriber_id' is set
        if ($subscriber_id === null || (is_array($subscriber_id) && count($subscriber_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscriber_id when calling deletePagesPageIdSubscribersSubscriberId'
            );
        }



        $resourcePath = '/pages/{page_id}/subscribers/{subscriber_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip_unsubscription_notification,
            'skip_unsubscription_notification', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }
        // path params
        if ($subscriber_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriber_id' . '}',
                ObjectSerializer::toPathValue($subscriber_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagesPageIdSubscribers
     *
     * Get a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $q If this is specified, search the contact information (email, endpoint, or phone number) for the provided value. This parameter doesn’t support searching for Slack subscribers. (optional)
     * @param  string $type If specified, only return subscribers of the indicated type. (optional)
     * @param  string $state If this is present, only return subscribers in this state. Specify state \&quot;all\&quot; to find subscribers in any states. (optional, default to 'active')
     * @param  int $limit The maximum number of rows to return. If a text query string is specified (q&#x3D;), the default and maximum limit is 100. If the text query string is not specified, the default and maximum limit are not set, and not providing a limit will return all the subscribers. Beginning February 28, 2023, a default limit of 100 will be imposed and this endpoint will return paginated data (i.e. will no longer return all subscribers) even if this query parameter is not provided. (optional)
     * @param  int $page The page offset of subscribers. The first page is page 0, the second page 1, etc. This skips page * limit subscribers. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional, default to 0)
     * @param  string $sort_field The field on which to sort: &#39;primary&#39; to indicate sorting by the identifying field, &#39;created_at&#39; for sorting by creation timestamp, &#39;quarantined_at&#39; for sorting by quarantine timestamp, and &#39;relevance&#39; which sorts by the relevancy of the search text. &#39;relevance&#39; is not a valid parameter if no search text is supplied. (optional, default to 'primary')
     * @param  string $sort_direction The sort direction of the listing. (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Subscriber[]|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function getPagesPageIdSubscribers($page_id, $q = null, $type = null, $state = 'active', $limit = null, $page = 0, $sort_field = 'primary', $sort_direction = 'asc', string $contentType = self::contentTypes['getPagesPageIdSubscribers'][0])
    {
        list($response) = $this->getPagesPageIdSubscribersWithHttpInfo($page_id, $q, $type, $state, $limit, $page, $sort_field, $sort_direction, $contentType);
        return $response;
    }

    /**
     * Operation getPagesPageIdSubscribersWithHttpInfo
     *
     * Get a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $q If this is specified, search the contact information (email, endpoint, or phone number) for the provided value. This parameter doesn’t support searching for Slack subscribers. (optional)
     * @param  string $type If specified, only return subscribers of the indicated type. (optional)
     * @param  string $state If this is present, only return subscribers in this state. Specify state \&quot;all\&quot; to find subscribers in any states. (optional, default to 'active')
     * @param  int $limit The maximum number of rows to return. If a text query string is specified (q&#x3D;), the default and maximum limit is 100. If the text query string is not specified, the default and maximum limit are not set, and not providing a limit will return all the subscribers. Beginning February 28, 2023, a default limit of 100 will be imposed and this endpoint will return paginated data (i.e. will no longer return all subscribers) even if this query parameter is not provided. (optional)
     * @param  int $page The page offset of subscribers. The first page is page 0, the second page 1, etc. This skips page * limit subscribers. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional, default to 0)
     * @param  string $sort_field The field on which to sort: &#39;primary&#39; to indicate sorting by the identifying field, &#39;created_at&#39; for sorting by creation timestamp, &#39;quarantined_at&#39; for sorting by quarantine timestamp, and &#39;relevance&#39; which sorts by the relevancy of the search text. &#39;relevance&#39; is not a valid parameter if no search text is supplied. (optional, default to 'primary')
     * @param  string $sort_direction The sort direction of the listing. (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Subscriber[]|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesPageIdSubscribersWithHttpInfo($page_id, $q = null, $type = null, $state = 'active', $limit = null, $page = 0, $sort_field = 'primary', $sort_direction = 'asc', string $contentType = self::contentTypes['getPagesPageIdSubscribers'][0])
    {
        $request = $this->getPagesPageIdSubscribersRequest($page_id, $q, $type, $state, $limit, $page, $sort_field, $sort_direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Subscriber[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Subscriber[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Subscriber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Subscriber[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Subscriber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesPageIdSubscribersAsync
     *
     * Get a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $q If this is specified, search the contact information (email, endpoint, or phone number) for the provided value. This parameter doesn’t support searching for Slack subscribers. (optional)
     * @param  string $type If specified, only return subscribers of the indicated type. (optional)
     * @param  string $state If this is present, only return subscribers in this state. Specify state \&quot;all\&quot; to find subscribers in any states. (optional, default to 'active')
     * @param  int $limit The maximum number of rows to return. If a text query string is specified (q&#x3D;), the default and maximum limit is 100. If the text query string is not specified, the default and maximum limit are not set, and not providing a limit will return all the subscribers. Beginning February 28, 2023, a default limit of 100 will be imposed and this endpoint will return paginated data (i.e. will no longer return all subscribers) even if this query parameter is not provided. (optional)
     * @param  int $page The page offset of subscribers. The first page is page 0, the second page 1, etc. This skips page * limit subscribers. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional, default to 0)
     * @param  string $sort_field The field on which to sort: &#39;primary&#39; to indicate sorting by the identifying field, &#39;created_at&#39; for sorting by creation timestamp, &#39;quarantined_at&#39; for sorting by quarantine timestamp, and &#39;relevance&#39; which sorts by the relevancy of the search text. &#39;relevance&#39; is not a valid parameter if no search text is supplied. (optional, default to 'primary')
     * @param  string $sort_direction The sort direction of the listing. (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersAsync($page_id, $q = null, $type = null, $state = 'active', $limit = null, $page = 0, $sort_field = 'primary', $sort_direction = 'asc', string $contentType = self::contentTypes['getPagesPageIdSubscribers'][0])
    {
        return $this->getPagesPageIdSubscribersAsyncWithHttpInfo($page_id, $q, $type, $state, $limit, $page, $sort_field, $sort_direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesPageIdSubscribersAsyncWithHttpInfo
     *
     * Get a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $q If this is specified, search the contact information (email, endpoint, or phone number) for the provided value. This parameter doesn’t support searching for Slack subscribers. (optional)
     * @param  string $type If specified, only return subscribers of the indicated type. (optional)
     * @param  string $state If this is present, only return subscribers in this state. Specify state \&quot;all\&quot; to find subscribers in any states. (optional, default to 'active')
     * @param  int $limit The maximum number of rows to return. If a text query string is specified (q&#x3D;), the default and maximum limit is 100. If the text query string is not specified, the default and maximum limit are not set, and not providing a limit will return all the subscribers. Beginning February 28, 2023, a default limit of 100 will be imposed and this endpoint will return paginated data (i.e. will no longer return all subscribers) even if this query parameter is not provided. (optional)
     * @param  int $page The page offset of subscribers. The first page is page 0, the second page 1, etc. This skips page * limit subscribers. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional, default to 0)
     * @param  string $sort_field The field on which to sort: &#39;primary&#39; to indicate sorting by the identifying field, &#39;created_at&#39; for sorting by creation timestamp, &#39;quarantined_at&#39; for sorting by quarantine timestamp, and &#39;relevance&#39; which sorts by the relevancy of the search text. &#39;relevance&#39; is not a valid parameter if no search text is supplied. (optional, default to 'primary')
     * @param  string $sort_direction The sort direction of the listing. (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersAsyncWithHttpInfo($page_id, $q = null, $type = null, $state = 'active', $limit = null, $page = 0, $sort_field = 'primary', $sort_direction = 'asc', string $contentType = self::contentTypes['getPagesPageIdSubscribers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Subscriber[]';
        $request = $this->getPagesPageIdSubscribersRequest($page_id, $q, $type, $state, $limit, $page, $sort_field, $sort_direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagesPageIdSubscribers'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $q If this is specified, search the contact information (email, endpoint, or phone number) for the provided value. This parameter doesn’t support searching for Slack subscribers. (optional)
     * @param  string $type If specified, only return subscribers of the indicated type. (optional)
     * @param  string $state If this is present, only return subscribers in this state. Specify state \&quot;all\&quot; to find subscribers in any states. (optional, default to 'active')
     * @param  int $limit The maximum number of rows to return. If a text query string is specified (q&#x3D;), the default and maximum limit is 100. If the text query string is not specified, the default and maximum limit are not set, and not providing a limit will return all the subscribers. Beginning February 28, 2023, a default limit of 100 will be imposed and this endpoint will return paginated data (i.e. will no longer return all subscribers) even if this query parameter is not provided. (optional)
     * @param  int $page The page offset of subscribers. The first page is page 0, the second page 1, etc. This skips page * limit subscribers. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional, default to 0)
     * @param  string $sort_field The field on which to sort: &#39;primary&#39; to indicate sorting by the identifying field, &#39;created_at&#39; for sorting by creation timestamp, &#39;quarantined_at&#39; for sorting by quarantine timestamp, and &#39;relevance&#39; which sorts by the relevancy of the search text. &#39;relevance&#39; is not a valid parameter if no search text is supplied. (optional, default to 'primary')
     * @param  string $sort_direction The sort direction of the listing. (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPagesPageIdSubscribersRequest($page_id, $q = null, $type = null, $state = 'active', $limit = null, $page = 0, $sort_field = 'primary', $sort_direction = 'asc', string $contentType = self::contentTypes['getPagesPageIdSubscribers'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling getPagesPageIdSubscribers'
            );
        }









        $resourcePath = '/pages/{page_id}/subscribers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_field,
            'sort_field', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sort_direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagesPageIdSubscribersCount
     *
     * Get a count of subscribers by type
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $type If this is present, only count subscribers of this type. (optional)
     * @param  string $state If this is present, only count subscribers in this state. Specify state \&quot;all\&quot; to count subscribers in any states. (optional, default to 'active')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SubscriberCountByType|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function getPagesPageIdSubscribersCount($page_id, $type = null, $state = 'active', string $contentType = self::contentTypes['getPagesPageIdSubscribersCount'][0])
    {
        list($response) = $this->getPagesPageIdSubscribersCountWithHttpInfo($page_id, $type, $state, $contentType);
        return $response;
    }

    /**
     * Operation getPagesPageIdSubscribersCountWithHttpInfo
     *
     * Get a count of subscribers by type
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $type If this is present, only count subscribers of this type. (optional)
     * @param  string $state If this is present, only count subscribers in this state. Specify state \&quot;all\&quot; to count subscribers in any states. (optional, default to 'active')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SubscriberCountByType|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesPageIdSubscribersCountWithHttpInfo($page_id, $type = null, $state = 'active', string $contentType = self::contentTypes['getPagesPageIdSubscribersCount'][0])
    {
        $request = $this->getPagesPageIdSubscribersCountRequest($page_id, $type, $state, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SubscriberCountByType' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SubscriberCountByType' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SubscriberCountByType', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SubscriberCountByType';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SubscriberCountByType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesPageIdSubscribersCountAsync
     *
     * Get a count of subscribers by type
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $type If this is present, only count subscribers of this type. (optional)
     * @param  string $state If this is present, only count subscribers in this state. Specify state \&quot;all\&quot; to count subscribers in any states. (optional, default to 'active')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersCountAsync($page_id, $type = null, $state = 'active', string $contentType = self::contentTypes['getPagesPageIdSubscribersCount'][0])
    {
        return $this->getPagesPageIdSubscribersCountAsyncWithHttpInfo($page_id, $type, $state, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesPageIdSubscribersCountAsyncWithHttpInfo
     *
     * Get a count of subscribers by type
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $type If this is present, only count subscribers of this type. (optional)
     * @param  string $state If this is present, only count subscribers in this state. Specify state \&quot;all\&quot; to count subscribers in any states. (optional, default to 'active')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersCountAsyncWithHttpInfo($page_id, $type = null, $state = 'active', string $contentType = self::contentTypes['getPagesPageIdSubscribersCount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SubscriberCountByType';
        $request = $this->getPagesPageIdSubscribersCountRequest($page_id, $type, $state, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagesPageIdSubscribersCount'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $type If this is present, only count subscribers of this type. (optional)
     * @param  string $state If this is present, only count subscribers in this state. Specify state \&quot;all\&quot; to count subscribers in any states. (optional, default to 'active')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPagesPageIdSubscribersCountRequest($page_id, $type = null, $state = 'active', string $contentType = self::contentTypes['getPagesPageIdSubscribersCount'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling getPagesPageIdSubscribersCount'
            );
        }




        $resourcePath = '/pages/{page_id}/subscribers/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagesPageIdSubscribersHistogramByState
     *
     * Get a histogram of subscribers by type and then state
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersHistogramByState'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SubscriberCountByTypeAndState|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function getPagesPageIdSubscribersHistogramByState($page_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersHistogramByState'][0])
    {
        list($response) = $this->getPagesPageIdSubscribersHistogramByStateWithHttpInfo($page_id, $contentType);
        return $response;
    }

    /**
     * Operation getPagesPageIdSubscribersHistogramByStateWithHttpInfo
     *
     * Get a histogram of subscribers by type and then state
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersHistogramByState'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SubscriberCountByTypeAndState|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesPageIdSubscribersHistogramByStateWithHttpInfo($page_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersHistogramByState'][0])
    {
        $request = $this->getPagesPageIdSubscribersHistogramByStateRequest($page_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SubscriberCountByTypeAndState' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SubscriberCountByTypeAndState' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SubscriberCountByTypeAndState', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SubscriberCountByTypeAndState';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SubscriberCountByTypeAndState',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesPageIdSubscribersHistogramByStateAsync
     *
     * Get a histogram of subscribers by type and then state
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersHistogramByState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersHistogramByStateAsync($page_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersHistogramByState'][0])
    {
        return $this->getPagesPageIdSubscribersHistogramByStateAsyncWithHttpInfo($page_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesPageIdSubscribersHistogramByStateAsyncWithHttpInfo
     *
     * Get a histogram of subscribers by type and then state
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersHistogramByState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersHistogramByStateAsyncWithHttpInfo($page_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersHistogramByState'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SubscriberCountByTypeAndState';
        $request = $this->getPagesPageIdSubscribersHistogramByStateRequest($page_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagesPageIdSubscribersHistogramByState'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersHistogramByState'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPagesPageIdSubscribersHistogramByStateRequest($page_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersHistogramByState'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling getPagesPageIdSubscribersHistogramByState'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/histogram_by_state';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagesPageIdSubscribersSubscriberId
     *
     * Get a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function getPagesPageIdSubscribersSubscriberId($page_id, $subscriber_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersSubscriberId'][0])
    {
        list($response) = $this->getPagesPageIdSubscribersSubscriberIdWithHttpInfo($page_id, $subscriber_id, $contentType);
        return $response;
    }

    /**
     * Operation getPagesPageIdSubscribersSubscriberIdWithHttpInfo
     *
     * Get a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesPageIdSubscribersSubscriberIdWithHttpInfo($page_id, $subscriber_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersSubscriberId'][0])
    {
        $request = $this->getPagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Subscriber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Subscriber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Subscriber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Subscriber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Subscriber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesPageIdSubscribersSubscriberIdAsync
     *
     * Get a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersSubscriberIdAsync($page_id, $subscriber_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersSubscriberId'][0])
    {
        return $this->getPagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo($page_id, $subscriber_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo
     *
     * Get a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo($page_id, $subscriber_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersSubscriberId'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Subscriber';
        $request = $this->getPagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagesPageIdSubscribersSubscriberId'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, string $contentType = self::contentTypes['getPagesPageIdSubscribersSubscriberId'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling getPagesPageIdSubscribersSubscriberId'
            );
        }

        // verify the required parameter 'subscriber_id' is set
        if ($subscriber_id === null || (is_array($subscriber_id) && count($subscriber_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscriber_id when calling getPagesPageIdSubscribersSubscriberId'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/{subscriber_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }
        // path params
        if ($subscriber_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriber_id' . '}',
                ObjectSerializer::toPathValue($subscriber_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPagesPageIdSubscribersUnsubscribed
     *
     * Get a list of unsubscribed subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  int $page Page offset to fetch. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  int $per_page Number of results to return per page. Beginning February 28, 2023, a default and maximum limit of 100 will be imposed and this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersUnsubscribed'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Subscriber[]|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function getPagesPageIdSubscribersUnsubscribed($page_id, $page = null, $per_page = null, string $contentType = self::contentTypes['getPagesPageIdSubscribersUnsubscribed'][0])
    {
        list($response) = $this->getPagesPageIdSubscribersUnsubscribedWithHttpInfo($page_id, $page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation getPagesPageIdSubscribersUnsubscribedWithHttpInfo
     *
     * Get a list of unsubscribed subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  int $page Page offset to fetch. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  int $per_page Number of results to return per page. Beginning February 28, 2023, a default and maximum limit of 100 will be imposed and this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersUnsubscribed'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Subscriber[]|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPagesPageIdSubscribersUnsubscribedWithHttpInfo($page_id, $page = null, $per_page = null, string $contentType = self::contentTypes['getPagesPageIdSubscribersUnsubscribed'][0])
    {
        $request = $this->getPagesPageIdSubscribersUnsubscribedRequest($page_id, $page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Subscriber[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Subscriber[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Subscriber[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Subscriber[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Subscriber[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPagesPageIdSubscribersUnsubscribedAsync
     *
     * Get a list of unsubscribed subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  int $page Page offset to fetch. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  int $per_page Number of results to return per page. Beginning February 28, 2023, a default and maximum limit of 100 will be imposed and this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersUnsubscribed'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersUnsubscribedAsync($page_id, $page = null, $per_page = null, string $contentType = self::contentTypes['getPagesPageIdSubscribersUnsubscribed'][0])
    {
        return $this->getPagesPageIdSubscribersUnsubscribedAsyncWithHttpInfo($page_id, $page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPagesPageIdSubscribersUnsubscribedAsyncWithHttpInfo
     *
     * Get a list of unsubscribed subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  int $page Page offset to fetch. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  int $per_page Number of results to return per page. Beginning February 28, 2023, a default and maximum limit of 100 will be imposed and this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersUnsubscribed'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPagesPageIdSubscribersUnsubscribedAsyncWithHttpInfo($page_id, $page = null, $per_page = null, string $contentType = self::contentTypes['getPagesPageIdSubscribersUnsubscribed'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Subscriber[]';
        $request = $this->getPagesPageIdSubscribersUnsubscribedRequest($page_id, $page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPagesPageIdSubscribersUnsubscribed'
     *
     * @param  string $page_id Page identifier (required)
     * @param  int $page Page offset to fetch. Beginning February 28, 2023, this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  int $per_page Number of results to return per page. Beginning February 28, 2023, a default and maximum limit of 100 will be imposed and this endpoint will return paginated data even if this query parameter is not provided. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPagesPageIdSubscribersUnsubscribed'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPagesPageIdSubscribersUnsubscribedRequest($page_id, $page = null, $per_page = null, string $contentType = self::contentTypes['getPagesPageIdSubscribersUnsubscribed'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling getPagesPageIdSubscribersUnsubscribed'
            );
        }




        $resourcePath = '/pages/{page_id}/subscribers/unsubscribed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchPagesPageIdSubscribersSubscriberId
     *
     * Update a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  \OpenAPI\Client\Model\PatchPagesPageIdSubscribers $patch_pages_page_id_subscribers patch_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function patchPagesPageIdSubscribersSubscriberId($page_id, $subscriber_id, $patch_pages_page_id_subscribers, string $contentType = self::contentTypes['patchPagesPageIdSubscribersSubscriberId'][0])
    {
        list($response) = $this->patchPagesPageIdSubscribersSubscriberIdWithHttpInfo($page_id, $subscriber_id, $patch_pages_page_id_subscribers, $contentType);
        return $response;
    }

    /**
     * Operation patchPagesPageIdSubscribersSubscriberIdWithHttpInfo
     *
     * Update a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  \OpenAPI\Client\Model\PatchPagesPageIdSubscribers $patch_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchPagesPageIdSubscribersSubscriberIdWithHttpInfo($page_id, $subscriber_id, $patch_pages_page_id_subscribers, string $contentType = self::contentTypes['patchPagesPageIdSubscribersSubscriberId'][0])
    {
        $request = $this->patchPagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $patch_pages_page_id_subscribers, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Subscriber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Subscriber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Subscriber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Subscriber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Subscriber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchPagesPageIdSubscribersSubscriberIdAsync
     *
     * Update a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  \OpenAPI\Client\Model\PatchPagesPageIdSubscribers $patch_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPagesPageIdSubscribersSubscriberIdAsync($page_id, $subscriber_id, $patch_pages_page_id_subscribers, string $contentType = self::contentTypes['patchPagesPageIdSubscribersSubscriberId'][0])
    {
        return $this->patchPagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo($page_id, $subscriber_id, $patch_pages_page_id_subscribers, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchPagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo
     *
     * Update a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  \OpenAPI\Client\Model\PatchPagesPageIdSubscribers $patch_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPagesPageIdSubscribersSubscriberIdAsyncWithHttpInfo($page_id, $subscriber_id, $patch_pages_page_id_subscribers, string $contentType = self::contentTypes['patchPagesPageIdSubscribersSubscriberId'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Subscriber';
        $request = $this->patchPagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $patch_pages_page_id_subscribers, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchPagesPageIdSubscribersSubscriberId'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  \OpenAPI\Client\Model\PatchPagesPageIdSubscribers $patch_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['patchPagesPageIdSubscribersSubscriberId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function patchPagesPageIdSubscribersSubscriberIdRequest($page_id, $subscriber_id, $patch_pages_page_id_subscribers, string $contentType = self::contentTypes['patchPagesPageIdSubscribersSubscriberId'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling patchPagesPageIdSubscribersSubscriberId'
            );
        }

        // verify the required parameter 'subscriber_id' is set
        if ($subscriber_id === null || (is_array($subscriber_id) && count($subscriber_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscriber_id when calling patchPagesPageIdSubscribersSubscriberId'
            );
        }

        // verify the required parameter 'patch_pages_page_id_subscribers' is set
        if ($patch_pages_page_id_subscribers === null || (is_array($patch_pages_page_id_subscribers) && count($patch_pages_page_id_subscribers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_pages_page_id_subscribers when calling patchPagesPageIdSubscribersSubscriberId'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/{subscriber_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }
        // path params
        if ($subscriber_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriber_id' . '}',
                ObjectSerializer::toPathValue($subscriber_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patch_pages_page_id_subscribers)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patch_pages_page_id_subscribers));
            } else {
                $httpBody = $patch_pages_page_id_subscribers;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagesPageIdSubscribers
     *
     * Create a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribers $post_pages_page_id_subscribers post_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity
     */
    public function postPagesPageIdSubscribers($page_id, $post_pages_page_id_subscribers, string $contentType = self::contentTypes['postPagesPageIdSubscribers'][0])
    {
        list($response) = $this->postPagesPageIdSubscribersWithHttpInfo($page_id, $post_pages_page_id_subscribers, $contentType);
        return $response;
    }

    /**
     * Operation postPagesPageIdSubscribersWithHttpInfo
     *
     * Create a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribers $post_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Subscriber|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity|\OpenAPI\Client\Model\ErrorEntity, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagesPageIdSubscribersWithHttpInfo($page_id, $post_pages_page_id_subscribers, string $contentType = self::contentTypes['postPagesPageIdSubscribers'][0])
    {
        $request = $this->postPagesPageIdSubscribersRequest($page_id, $post_pages_page_id_subscribers, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Subscriber' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Subscriber' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Subscriber', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\OpenAPI\Client\Model\ErrorEntity' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorEntity' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorEntity', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Subscriber';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Subscriber',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagesPageIdSubscribersAsync
     *
     * Create a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribers $post_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersAsync($page_id, $post_pages_page_id_subscribers, string $contentType = self::contentTypes['postPagesPageIdSubscribers'][0])
    {
        return $this->postPagesPageIdSubscribersAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagesPageIdSubscribersAsyncWithHttpInfo
     *
     * Create a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribers $post_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers, string $contentType = self::contentTypes['postPagesPageIdSubscribers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Subscriber';
        $request = $this->postPagesPageIdSubscribersRequest($page_id, $post_pages_page_id_subscribers, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagesPageIdSubscribers'
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribers $post_pages_page_id_subscribers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPagesPageIdSubscribersRequest($page_id, $post_pages_page_id_subscribers, string $contentType = self::contentTypes['postPagesPageIdSubscribers'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling postPagesPageIdSubscribers'
            );
        }

        // verify the required parameter 'post_pages_page_id_subscribers' is set
        if ($post_pages_page_id_subscribers === null || (is_array($post_pages_page_id_subscribers) && count($post_pages_page_id_subscribers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_pages_page_id_subscribers when calling postPagesPageIdSubscribers'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_pages_page_id_subscribers)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_pages_page_id_subscribers));
            } else {
                $httpBody = $post_pages_page_id_subscribers;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagesPageIdSubscribersReactivate
     *
     * Reactivate a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersReactivate $post_pages_page_id_subscribers_reactivate post_pages_page_id_subscribers_reactivate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersReactivate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPagesPageIdSubscribersReactivate($page_id, $post_pages_page_id_subscribers_reactivate, string $contentType = self::contentTypes['postPagesPageIdSubscribersReactivate'][0])
    {
        $this->postPagesPageIdSubscribersReactivateWithHttpInfo($page_id, $post_pages_page_id_subscribers_reactivate, $contentType);
    }

    /**
     * Operation postPagesPageIdSubscribersReactivateWithHttpInfo
     *
     * Reactivate a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersReactivate $post_pages_page_id_subscribers_reactivate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersReactivate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagesPageIdSubscribersReactivateWithHttpInfo($page_id, $post_pages_page_id_subscribers_reactivate, string $contentType = self::contentTypes['postPagesPageIdSubscribersReactivate'][0])
    {
        $request = $this->postPagesPageIdSubscribersReactivateRequest($page_id, $post_pages_page_id_subscribers_reactivate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagesPageIdSubscribersReactivateAsync
     *
     * Reactivate a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersReactivate $post_pages_page_id_subscribers_reactivate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersReactivate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersReactivateAsync($page_id, $post_pages_page_id_subscribers_reactivate, string $contentType = self::contentTypes['postPagesPageIdSubscribersReactivate'][0])
    {
        return $this->postPagesPageIdSubscribersReactivateAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers_reactivate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagesPageIdSubscribersReactivateAsyncWithHttpInfo
     *
     * Reactivate a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersReactivate $post_pages_page_id_subscribers_reactivate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersReactivate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersReactivateAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers_reactivate, string $contentType = self::contentTypes['postPagesPageIdSubscribersReactivate'][0])
    {
        $returnType = '';
        $request = $this->postPagesPageIdSubscribersReactivateRequest($page_id, $post_pages_page_id_subscribers_reactivate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagesPageIdSubscribersReactivate'
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersReactivate $post_pages_page_id_subscribers_reactivate (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersReactivate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPagesPageIdSubscribersReactivateRequest($page_id, $post_pages_page_id_subscribers_reactivate, string $contentType = self::contentTypes['postPagesPageIdSubscribersReactivate'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling postPagesPageIdSubscribersReactivate'
            );
        }

        // verify the required parameter 'post_pages_page_id_subscribers_reactivate' is set
        if ($post_pages_page_id_subscribers_reactivate === null || (is_array($post_pages_page_id_subscribers_reactivate) && count($post_pages_page_id_subscribers_reactivate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_pages_page_id_subscribers_reactivate when calling postPagesPageIdSubscribersReactivate'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/reactivate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_pages_page_id_subscribers_reactivate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_pages_page_id_subscribers_reactivate));
            } else {
                $httpBody = $post_pages_page_id_subscribers_reactivate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagesPageIdSubscribersResendConfirmation
     *
     * Resend confirmations to a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersResendConfirmation $post_pages_page_id_subscribers_resend_confirmation post_pages_page_id_subscribers_resend_confirmation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersResendConfirmation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPagesPageIdSubscribersResendConfirmation($page_id, $post_pages_page_id_subscribers_resend_confirmation, string $contentType = self::contentTypes['postPagesPageIdSubscribersResendConfirmation'][0])
    {
        $this->postPagesPageIdSubscribersResendConfirmationWithHttpInfo($page_id, $post_pages_page_id_subscribers_resend_confirmation, $contentType);
    }

    /**
     * Operation postPagesPageIdSubscribersResendConfirmationWithHttpInfo
     *
     * Resend confirmations to a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersResendConfirmation $post_pages_page_id_subscribers_resend_confirmation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersResendConfirmation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagesPageIdSubscribersResendConfirmationWithHttpInfo($page_id, $post_pages_page_id_subscribers_resend_confirmation, string $contentType = self::contentTypes['postPagesPageIdSubscribersResendConfirmation'][0])
    {
        $request = $this->postPagesPageIdSubscribersResendConfirmationRequest($page_id, $post_pages_page_id_subscribers_resend_confirmation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagesPageIdSubscribersResendConfirmationAsync
     *
     * Resend confirmations to a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersResendConfirmation $post_pages_page_id_subscribers_resend_confirmation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersResendConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersResendConfirmationAsync($page_id, $post_pages_page_id_subscribers_resend_confirmation, string $contentType = self::contentTypes['postPagesPageIdSubscribersResendConfirmation'][0])
    {
        return $this->postPagesPageIdSubscribersResendConfirmationAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers_resend_confirmation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagesPageIdSubscribersResendConfirmationAsyncWithHttpInfo
     *
     * Resend confirmations to a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersResendConfirmation $post_pages_page_id_subscribers_resend_confirmation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersResendConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersResendConfirmationAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers_resend_confirmation, string $contentType = self::contentTypes['postPagesPageIdSubscribersResendConfirmation'][0])
    {
        $returnType = '';
        $request = $this->postPagesPageIdSubscribersResendConfirmationRequest($page_id, $post_pages_page_id_subscribers_resend_confirmation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagesPageIdSubscribersResendConfirmation'
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersResendConfirmation $post_pages_page_id_subscribers_resend_confirmation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersResendConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPagesPageIdSubscribersResendConfirmationRequest($page_id, $post_pages_page_id_subscribers_resend_confirmation, string $contentType = self::contentTypes['postPagesPageIdSubscribersResendConfirmation'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling postPagesPageIdSubscribersResendConfirmation'
            );
        }

        // verify the required parameter 'post_pages_page_id_subscribers_resend_confirmation' is set
        if ($post_pages_page_id_subscribers_resend_confirmation === null || (is_array($post_pages_page_id_subscribers_resend_confirmation) && count($post_pages_page_id_subscribers_resend_confirmation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_pages_page_id_subscribers_resend_confirmation when calling postPagesPageIdSubscribersResendConfirmation'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/resend_confirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_pages_page_id_subscribers_resend_confirmation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_pages_page_id_subscribers_resend_confirmation));
            } else {
                $httpBody = $post_pages_page_id_subscribers_resend_confirmation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagesPageIdSubscribersSubscriberIdResendConfirmation
     *
     * Resend confirmation to a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPagesPageIdSubscribersSubscriberIdResendConfirmation($page_id, $subscriber_id, string $contentType = self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'][0])
    {
        $this->postPagesPageIdSubscribersSubscriberIdResendConfirmationWithHttpInfo($page_id, $subscriber_id, $contentType);
    }

    /**
     * Operation postPagesPageIdSubscribersSubscriberIdResendConfirmationWithHttpInfo
     *
     * Resend confirmation to a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagesPageIdSubscribersSubscriberIdResendConfirmationWithHttpInfo($page_id, $subscriber_id, string $contentType = self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'][0])
    {
        $request = $this->postPagesPageIdSubscribersSubscriberIdResendConfirmationRequest($page_id, $subscriber_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagesPageIdSubscribersSubscriberIdResendConfirmationAsync
     *
     * Resend confirmation to a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersSubscriberIdResendConfirmationAsync($page_id, $subscriber_id, string $contentType = self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'][0])
    {
        return $this->postPagesPageIdSubscribersSubscriberIdResendConfirmationAsyncWithHttpInfo($page_id, $subscriber_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagesPageIdSubscribersSubscriberIdResendConfirmationAsyncWithHttpInfo
     *
     * Resend confirmation to a subscriber
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersSubscriberIdResendConfirmationAsyncWithHttpInfo($page_id, $subscriber_id, string $contentType = self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'][0])
    {
        $returnType = '';
        $request = $this->postPagesPageIdSubscribersSubscriberIdResendConfirmationRequest($page_id, $subscriber_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagesPageIdSubscribersSubscriberIdResendConfirmation'
     *
     * @param  string $page_id Page identifier (required)
     * @param  string $subscriber_id Subscriber Identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPagesPageIdSubscribersSubscriberIdResendConfirmationRequest($page_id, $subscriber_id, string $contentType = self::contentTypes['postPagesPageIdSubscribersSubscriberIdResendConfirmation'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling postPagesPageIdSubscribersSubscriberIdResendConfirmation'
            );
        }

        // verify the required parameter 'subscriber_id' is set
        if ($subscriber_id === null || (is_array($subscriber_id) && count($subscriber_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subscriber_id when calling postPagesPageIdSubscribersSubscriberIdResendConfirmation'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/{subscriber_id}/resend_confirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }
        // path params
        if ($subscriber_id !== null) {
            $resourcePath = str_replace(
                '{' . 'subscriber_id' . '}',
                ObjectSerializer::toPathValue($subscriber_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPagesPageIdSubscribersUnsubscribe
     *
     * Unsubscribe a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersUnsubscribe $post_pages_page_id_subscribers_unsubscribe post_pages_page_id_subscribers_unsubscribe (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersUnsubscribe'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPagesPageIdSubscribersUnsubscribe($page_id, $post_pages_page_id_subscribers_unsubscribe, string $contentType = self::contentTypes['postPagesPageIdSubscribersUnsubscribe'][0])
    {
        $this->postPagesPageIdSubscribersUnsubscribeWithHttpInfo($page_id, $post_pages_page_id_subscribers_unsubscribe, $contentType);
    }

    /**
     * Operation postPagesPageIdSubscribersUnsubscribeWithHttpInfo
     *
     * Unsubscribe a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersUnsubscribe $post_pages_page_id_subscribers_unsubscribe (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersUnsubscribe'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPagesPageIdSubscribersUnsubscribeWithHttpInfo($page_id, $post_pages_page_id_subscribers_unsubscribe, string $contentType = self::contentTypes['postPagesPageIdSubscribersUnsubscribe'][0])
    {
        $request = $this->postPagesPageIdSubscribersUnsubscribeRequest($page_id, $post_pages_page_id_subscribers_unsubscribe, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorEntity',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPagesPageIdSubscribersUnsubscribeAsync
     *
     * Unsubscribe a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersUnsubscribe $post_pages_page_id_subscribers_unsubscribe (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersUnsubscribe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersUnsubscribeAsync($page_id, $post_pages_page_id_subscribers_unsubscribe, string $contentType = self::contentTypes['postPagesPageIdSubscribersUnsubscribe'][0])
    {
        return $this->postPagesPageIdSubscribersUnsubscribeAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers_unsubscribe, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPagesPageIdSubscribersUnsubscribeAsyncWithHttpInfo
     *
     * Unsubscribe a list of subscribers
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersUnsubscribe $post_pages_page_id_subscribers_unsubscribe (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersUnsubscribe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPagesPageIdSubscribersUnsubscribeAsyncWithHttpInfo($page_id, $post_pages_page_id_subscribers_unsubscribe, string $contentType = self::contentTypes['postPagesPageIdSubscribersUnsubscribe'][0])
    {
        $returnType = '';
        $request = $this->postPagesPageIdSubscribersUnsubscribeRequest($page_id, $post_pages_page_id_subscribers_unsubscribe, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPagesPageIdSubscribersUnsubscribe'
     *
     * @param  string $page_id Page identifier (required)
     * @param  \OpenAPI\Client\Model\PostPagesPageIdSubscribersUnsubscribe $post_pages_page_id_subscribers_unsubscribe (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postPagesPageIdSubscribersUnsubscribe'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postPagesPageIdSubscribersUnsubscribeRequest($page_id, $post_pages_page_id_subscribers_unsubscribe, string $contentType = self::contentTypes['postPagesPageIdSubscribersUnsubscribe'][0])
    {

        // verify the required parameter 'page_id' is set
        if ($page_id === null || (is_array($page_id) && count($page_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page_id when calling postPagesPageIdSubscribersUnsubscribe'
            );
        }

        // verify the required parameter 'post_pages_page_id_subscribers_unsubscribe' is set
        if ($post_pages_page_id_subscribers_unsubscribe === null || (is_array($post_pages_page_id_subscribers_unsubscribe) && count($post_pages_page_id_subscribers_unsubscribe) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $post_pages_page_id_subscribers_unsubscribe when calling postPagesPageIdSubscribersUnsubscribe'
            );
        }


        $resourcePath = '/pages/{page_id}/subscribers/unsubscribe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($page_id !== null) {
            $resourcePath = str_replace(
                '{' . 'page_id' . '}',
                ObjectSerializer::toPathValue($page_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($post_pages_page_id_subscribers_unsubscribe)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($post_pages_page_id_subscribers_unsubscribe));
            } else {
                $httpBody = $post_pages_page_id_subscribers_unsubscribe;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
